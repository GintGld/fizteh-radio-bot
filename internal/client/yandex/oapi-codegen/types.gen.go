// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package client

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
)

const (
	OAuthScopes        = "oAuth.Scopes"
	OAuthProxiedScopes = "oAuthProxied.Scopes"
)

// Defines values for AlbumMetaType.
const (
	AlbumMetaTypeMusic   AlbumMetaType = "music"
	AlbumMetaTypePodcast AlbumMetaType = "podcast"
	AlbumMetaTypeSingle  AlbumMetaType = "single"
)

// Defines values for AlbumType.
const (
	AlbumTypePodcast AlbumType = "podcast"
	AlbumTypeSingle  AlbumType = "single"
)

// Defines values for CoverType.
const (
	Mosaic CoverType = "mosaic"
	Pic    CoverType = "pic"
)

// Defines values for PlaylistVisibility.
const (
	Private PlaylistVisibility = "private"
	Public  PlaylistVisibility = "public"
)

// Defines values for SearchType.
const (
	SearchTypeAlbum   SearchType = "album"
	SearchTypeAll     SearchType = "all"
	SearchTypeArtist  SearchType = "artist"
	SearchTypePodcast SearchType = "podcast"
	SearchTypeTrack   SearchType = "track"
)

// Defines values for TrackDownloadInfoCodec.
const (
	Aac TrackDownloadInfoCodec = "aac"
	Mp3 TrackDownloadInfoCodec = "mp3"
)

// Album defines model for Album.
type Album struct {
	// Artists Артисты
	Artists []Artist `json:"artists"`

	// Available Доступен ли альбом
	Available bool `json:"available"`

	// AvailableForMobile Доступен ли альбом из приложения для телефона
	AvailableForMobile bool `json:"availableForMobile"`

	// AvailableForPremiumUsers Доступен ли альбом для пользователей с подпиской
	AvailableForPremiumUsers bool `json:"availableForPremiumUsers"`

	// AvailablePartially Доступен ли альбом частично для пользователей без подписки
	AvailablePartially bool `json:"availablePartially"`

	// Bests ID лучших треков альбома
	Bests []float32                `json:"bests"`
	Buy   []map[string]interface{} `json:"buy"`

	// CoverUri Ссылка на обложку
	CoverUri string `json:"coverUri"`

	// Error Ошибка получения альбома
	Error *string `json:"error"`

	// Genre Жанр музыки
	Genre string `json:"genre"`

	// Id Идентификатор альбома
	Id float32 `json:"id"`

	// Labels Лейблы
	Labels []AlbumLabels `json:"labels"`

	// MetaType Мета тип
	MetaType AlbumMetaType `json:"metaType"`

	// OgImage Ссылка на превью Open Graph
	OgImage string `json:"ogImage"`

	// Prerolls Прероллы
	Prerolls []map[string]interface{} `json:"prerolls"`

	// Recent Является ли альбом новым
	Recent bool `json:"recent"`

	// ReleaseDate Дата релиза в формате ISO 8601
	ReleaseDate string `json:"releaseDate"`

	// Title Название альбома
	Title string `json:"title"`

	// TrackCount Количество треков.
	TrackCount float32 `json:"trackCount"`

	// Type Тип альбома
	Type AlbumType `json:"type"`

	// VeryImportant Популярен ли альбом у слушателей
	VeryImportant bool `json:"veryImportant"`

	// Volumes Треки альбома, разделенные по дискам.
	Volumes *[][]Track `json:"volumes"`

	// Year Год релиза
	Year float32 `json:"year"`
}

// AlbumMetaType Мета тип
type AlbumMetaType string

// AlbumType Тип альбома
type AlbumType string

// AlbumLabels defines model for Album_labels.
type AlbumLabels struct {
	Id   *float32 `json:"id,omitempty"`
	Name *string  `json:"name,omitempty"`
}

// Artist defines model for Artist.
type Artist struct {
	Composer      bool                      `json:"composer"`
	Cover         *Cover                    `json:"cover,omitempty"`
	Decomposed    *[]map[string]interface{} `json:"decomposed"`
	Genres        []map[string]interface{}  `json:"genres"`
	Id            Artist_Id                 `json:"id"`
	Name          string                    `json:"name"`
	PopularTracks *[]Track                  `json:"popularTracks"`
	Regions       *[]string                 `json:"regions"`

	// TicketsAvailable Имеются ли в продаже билеты на концерт
	TicketsAvailable *bool `json:"ticketsAvailable"`
	Various          bool  `json:"various"`
}

// ArtistId0 defines model for .
type ArtistId0 = string

// ArtistId1 defines model for .
type ArtistId1 = float32

// Artist_Id defines model for Artist.Id.
type Artist_Id struct {
	union json.RawMessage
}

// Best лучший результат поиска
type Best struct {
	Result *Best_Result `json:"result,omitempty"`
	Text   *string      `json:"text,omitempty"`

	// Type Тип лучшего результата
	Type *string `json:"type,omitempty"`
}

// Best_Result defines model for Best.Result.
type Best_Result struct {
	union json.RawMessage
}

// Cover defines model for Cover.
type Cover struct {
	Custom bool `json:"custom"`

	// Dir Существует когда поле type = "pic"
	Dir *string `json:"dir,omitempty"`

	// Error If exists other properties is missing
	Error *string `json:"error,omitempty"`

	// ItemsUri Существует когда поле type = "mosaic"
	ItemsUri *[]string `json:"itemsUri,omitempty"`
	Type     CoverType `json:"type"`

	// Uri Существует когда поле type = "pic"
	Uri     *string `json:"uri,omitempty"`
	Version *string `json:"version,omitempty"`
}

// CoverType defines model for Cover.Type.
type CoverType string

// Genre defines model for Genre.
type Genre struct {
	// Color Цвет фона изображения
	Color       *string `json:"color,omitempty"`
	ComposerTop bool    `json:"composerTop"`

	// FullTitle Полный заголовок
	FullTitle *string `json:"fullTitle,omitempty"`

	// HideInRegions В каких регионах скрывать жанр
	HideInRegions *[]float32 `json:"hideInRegions,omitempty"`

	// Id Уникальный идентификатор жанра
	Id string `json:"id"`

	// Images Изображение жанра
	Images    map[string]string `json:"images"`
	RadioIcon *Icon             `json:"radioIcon,omitempty"`

	// ShowInMenu Показывать в меню
	ShowInMenu bool `json:"showInMenu"`

	// ShowInRegions Список регионов в которых отображается жанр в списках
	ShowInRegions *[]float32 `json:"showInRegions,omitempty"`
	SubGenres     *Genre     `json:"subGenres,omitempty"`

	// Title Заголовок жанра
	Title string `json:"title"`

	// Titles Словарь заголовков на разных языках, где ключ - язык
	Titles map[string]GenreTitles `json:"titles"`

	// UrlPart Часть ссылки на жанр для открытия в браузере
	UrlPart *string `json:"urlPart,omitempty"`

	// Weight Вес TODO (возможно, чем выше показатель, тем больше нравится пользователю)
	Weight float32 `json:"weight"`
}

// GenreTitles defines model for Genre_titles.
type GenreTitles struct {
	FullTitle string `json:"fullTitle"`
	Title     string `json:"title"`
}

// Icon defines model for Icon.
type Icon struct {
	BackgroundColor string `json:"backgroundColor"`
	ImageUrl        string `json:"imageUrl"`
}

// InvocationInfo defines model for InvocationInfo.
type InvocationInfo struct {
	AppName            *string `json:"app-name,omitempty"`
	ExecDurationMillis float32 `json:"exec-duration-millis"`
	Hostname           string  `json:"hostname"`
	ReqId              string  `json:"req-id"`
}

// Owner defines model for Owner.
type Owner struct {
	Login    string  `json:"login"`
	Name     string  `json:"name"`
	Sex      string  `json:"sex"`
	Uid      float32 `json:"uid"`
	Verified bool    `json:"verified"`
}

// Playlist play list data
type Playlist struct {
	Available            bool                      `json:"available"`
	BackgroundColor      string                    `json:"backgroundColor"`
	Collective           bool                      `json:"collective"`
	Cover                *Cover                    `json:"cover,omitempty"`
	Created              string                    `json:"created"`
	Description          string                    `json:"description"`
	DescriptionFormatted string                    `json:"descriptionFormatted"`
	DurationMs           float32                   `json:"durationMs"`
	IsBanner             bool                      `json:"isBanner"`
	IsPremiere           bool                      `json:"isPremiere"`
	Kind                 float32                   `json:"kind"`
	LikesCount           float32                   `json:"likesCount"`
	Modified             string                    `json:"modified"`
	OgImage              *string                   `json:"ogImage,omitempty"`
	Owner                Owner                     `json:"owner"`
	PlaylistUuid         string                    `json:"playlistUuid"`
	Prerolls             *[]map[string]interface{} `json:"prerolls,omitempty"`
	Revision             float32                   `json:"revision"`
	Snapshot             float32                   `json:"snapshot"`
	Tags                 []PlaylistTags            `json:"tags"`
	TextColor            string                    `json:"textColor"`
	Title                string                    `json:"title"`
	TrackCount           float32                   `json:"trackCount"`
	Tracks               []TrackItem               `json:"tracks"`
	Uid                  float32                   `json:"uid"`
	Visibility           PlaylistVisibility        `json:"visibility"`
}

// PlaylistVisibility defines model for Playlist.Visibility.
type PlaylistVisibility string

// PlaylistTags defines model for Playlist_tags.
type PlaylistTags struct {
	Id    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Search Результаты поиска
type Search struct {
	// Albums Найденные альбомы
	Albums struct {
		// Order Позиция блока
		Order float32 `json:"order"`

		// PerPage Максимальное количество результатов на странице.
		PerPage float32 `json:"perPage"`
		Results []Album `json:"results"`

		// Total Количество результатов
		Total float32 `json:"total"`

		// Type Тип результата
		Type string `json:"type"`
	} `json:"albums"`

	// Artists Найденные артисты
	Artists struct {
		// Order Позиция блока
		Order float32 `json:"order"`

		// PerPage Максимальное количество результатов на странице.
		PerPage float32  `json:"perPage"`
		Results []Artist `json:"results"`

		// Total Количество результатов
		Total float32 `json:"total"`

		// Type Тип результата
		Type string `json:"type"`
	} `json:"artists"`

	// Best лучший результат поиска
	Best Best `json:"best"`

	// MisspellCorrected Был ли исправлен запрос
	MisspellCorrected bool `json:"misspellCorrected"`

	// MisspellOriginal Оригинальный запрос
	MisspellOriginal *string `json:"misspellOriginal,omitempty"`

	// Nocorrect Было ли отключено исправление результата
	Nocorrect bool `json:"nocorrect"`

	// Page Текущая страница. Доступно, при использовании параметра type.
	Page *float32 `json:"page,omitempty"`

	// PerPage Результатов на странице. Доступно, при использовании параметра type.
	PerPage *float32 `json:"perPage,omitempty"`

	// Playlists Найденные альбомы
	Playlists struct {
		// Order Позиция блока
		Order float32 `json:"order"`

		// PerPage Максимальное количество результатов на странице.
		PerPage float32    `json:"perPage"`
		Results []Playlist `json:"results"`

		// Total Количество результатов
		Total float32 `json:"total"`

		// Type Тип результата
		Type string `json:"type"`
	} `json:"playlists"`

	// PodcastEpisodes Найденные выпуски подкастов
	PodcastEpisodes struct {
		// Order Позиция блока
		Order float32 `json:"order"`

		// PerPage Максимальное количество результатов на странице.
		PerPage float32                  `json:"perPage"`
		Results []map[string]interface{} `json:"results"`

		// Total Количество результатов
		Total float32 `json:"total"`

		// Type Тип результата
		Type string `json:"type"`
	} `json:"podcast_episodes"`

	// Podcasts Найденные подкасты
	Podcasts *struct {
		// Order Позиция блока
		Order float32 `json:"order"`

		// PerPage Максимальное количество результатов на странице.
		PerPage float32                  `json:"perPage"`
		Results []map[string]interface{} `json:"results"`

		// Total Количество результатов
		Total float32 `json:"total"`

		// Type Тип результата
		Type string `json:"type"`
	} `json:"podcasts,omitempty"`

	// SearchResultId ID запроса
	SearchResultId *string `json:"searchResultId,omitempty"`

	// Text Текст запроса
	Text string `json:"text"`

	// Tracks Найденные треки
	Tracks struct {
		// Order Позиция блока
		Order float32 `json:"order"`

		// PerPage Максимальное количество результатов на странице.
		PerPage float32 `json:"perPage"`
		Results []Track `json:"results"`

		// Total Количество результатов
		Total float32 `json:"total"`

		// Type Тип результата
		Type string `json:"type"`
	} `json:"tracks"`
	Type *SearchType `json:"type,omitempty"`

	// Videos Найденные видео
	Videos *struct {
		// Order Позиция блока
		Order float32 `json:"order"`

		// PerPage Максимальное количество результатов на странице.
		PerPage float32 `json:"perPage"`
		Results []Video `json:"results"`

		// Total Количество результатов
		Total float32 `json:"total"`

		// Type Тип результата
		Type string `json:"type"`
	} `json:"videos,omitempty"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	// Order Позиция блока
	Order float32 `json:"order"`

	// PerPage Максимальное количество результатов на странице.
	PerPage float32 `json:"perPage"`

	// Total Количество результатов
	Total float32 `json:"total"`

	// Type Тип результата
	Type string `json:"type"`
}

// SearchType defines model for SearchType.
type SearchType string

// Track defines model for Track.
type Track struct {
	Albums                         []Album  `json:"albums"`
	Artists                        []Artist `json:"artists"`
	Available                      bool     `json:"available"`
	AvailableForPremiumUsers       bool     `json:"availableForPremiumUsers"`
	AvailableFullWithoutPermission bool     `json:"availableFullWithoutPermission"`

	// CoverUri Cover uri template
	CoverUri          string             `json:"coverUri"`
	DurationMs        float32            `json:"durationMs"`
	FileSize          float32            `json:"fileSize"`
	Id                string             `json:"id"`
	LyricsAvailable   bool               `json:"lyricsAvailable"`
	Major             TrackMajor         `json:"major"`
	Normalization     TrackNormalization `json:"normalization"`
	OgImage           string             `json:"ogImage"`
	PreviewDurationMs float32            `json:"previewDurationMs"`
	RealId            string             `json:"realId"`
	RememberPosition  bool               `json:"rememberPosition"`
	StorageDir        string             `json:"storageDir"`
	Title             string             `json:"title"`
	Type              string             `json:"type"`
}

// TrackDownloadInfo информация о вариантах загрузки трека
type TrackDownloadInfo struct {
	// BitrateInKbps Битрейт аудиофайла в кбит/с
	BitrateInKbps float32 `json:"bitrateInKbps"`

	// Codec Кодек аудиофайла
	Codec TrackDownloadInfoCodec `json:"codec"`

	// Direct Прямая ли ссылка
	Direct bool `json:"direct"`

	// DownloadInfoUrl Ссылка на XML документ содержащий данные для загрузки трека
	DownloadInfoUrl string `json:"downloadInfoUrl"`

	// Gain Усиление
	Gain bool `json:"gain"`

	// Preview Предварительный просмотр
	Preview string `json:"preview"`
}

// TrackDownloadInfoCodec Кодек аудиофайла
type TrackDownloadInfoCodec string

// TrackItem defines model for TrackItem.
type TrackItem struct {
	Id        float32 `json:"id"`
	PlayCount float32 `json:"playCount"`
	Recent    bool    `json:"recent"`
	Timestamp string  `json:"timestamp"`
	Track     *Track  `json:"track,omitempty"`
}

// TrackMajor defines model for Track_major.
type TrackMajor struct {
	Id   float32 `json:"id"`
	Name string  `json:"name"`
}

// TrackNormalization defines model for Track_normalization.
type TrackNormalization struct {
	Gain float32 `json:"gain"`
	Peak float32 `json:"peak"`
}

// Video Видео
type Video struct {
	// Cover Ссылка на изображение
	Cover *string `json:"cover,omitempty"`

	// Duration Длительность видео в секундах
	Duration *float32 `json:"duration,omitempty"`

	// EmbedUrl Ссылка на видео
	EmbedUrl *string `json:"embedUrl,omitempty"`

	// HtmlAutoPlayVideoPlayer HTML тег для встраивания в разметку страницы
	HtmlAutoPlayVideoPlayer *string `json:"htmlAutoPlayVideoPlayer,omitempty"`

	// Provider Сервис поставляющий видео
	Provider *string `json:"provider,omitempty"`

	// ProviderVideoId Уникальный идентификатор видео на сервисе.
	ProviderVideoId *string   `json:"providerVideoId,omitempty"`
	Regions         *[]string `json:"regions,omitempty"`

	// Text Текст
	Text *string `json:"text,omitempty"`

	// ThumbnailUrl Ссылка на изображение
	ThumbnailUrl *string `json:"thumbnailUrl,omitempty"`

	// Title Название видео
	Title *string `json:"title,omitempty"`

	// YoutubeUrl Ссылка на видео Youtube
	YoutubeUrl *string `json:"youtubeUrl,omitempty"`
}

// InlineResponse20011 defines model for inline_response_200_11.
type InlineResponse20011 struct {
	InvocationInfo InvocationInfo `json:"invocationInfo"`
	Result         Album          `json:"result"`
}

// InlineResponse20022 defines model for inline_response_200_22.
type InlineResponse20022 struct {
	InvocationInfo InvocationInfo `json:"invocationInfo"`

	// Result Результаты поиска
	Result Search `json:"result"`
}

// InlineResponse20024 defines model for inline_response_200_24.
type InlineResponse20024 struct {
	InvocationInfo InvocationInfo `json:"invocationInfo"`

	// Result play list data
	Result Playlist `json:"result"`
}

// InlineResponse20030 defines model for inline_response_200_30.
type InlineResponse20030 struct {
	InvocationInfo InvocationInfo      `json:"invocationInfo"`
	Result         []TrackDownloadInfo `json:"result"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Text Текст запроса
	Text string `form:"text" json:"text"`

	// Page Номер страницы выдачи
	Page       float32    `form:"page" json:"page"`
	Type       SearchType `form:"type" json:"type"`
	Nococrrect *bool      `form:"nococrrect,omitempty" json:"nococrrect,omitempty"`
}

// AsArtistId0 returns the union data inside the Artist_Id as a ArtistId0
func (t Artist_Id) AsArtistId0() (ArtistId0, error) {
	var body ArtistId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtistId0 overwrites any union data inside the Artist_Id as the provided ArtistId0
func (t *Artist_Id) FromArtistId0(v ArtistId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtistId0 performs a merge with any union data inside the Artist_Id, using the provided ArtistId0
func (t *Artist_Id) MergeArtistId0(v ArtistId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArtistId1 returns the union data inside the Artist_Id as a ArtistId1
func (t Artist_Id) AsArtistId1() (ArtistId1, error) {
	var body ArtistId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtistId1 overwrites any union data inside the Artist_Id as the provided ArtistId1
func (t *Artist_Id) FromArtistId1(v ArtistId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtistId1 performs a merge with any union data inside the Artist_Id, using the provided ArtistId1
func (t *Artist_Id) MergeArtistId1(v ArtistId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Artist_Id) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Artist_Id) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTrack returns the union data inside the Best_Result as a Track
func (t Best_Result) AsTrack() (Track, error) {
	var body Track
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrack overwrites any union data inside the Best_Result as the provided Track
func (t *Best_Result) FromTrack(v Track) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrack performs a merge with any union data inside the Best_Result, using the provided Track
func (t *Best_Result) MergeTrack(v Track) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArtist returns the union data inside the Best_Result as a Artist
func (t Best_Result) AsArtist() (Artist, error) {
	var body Artist
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtist overwrites any union data inside the Best_Result as the provided Artist
func (t *Best_Result) FromArtist(v Artist) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtist performs a merge with any union data inside the Best_Result, using the provided Artist
func (t *Best_Result) MergeArtist(v Artist) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAlbum returns the union data inside the Best_Result as a Album
func (t Best_Result) AsAlbum() (Album, error) {
	var body Album
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlbum overwrites any union data inside the Best_Result as the provided Album
func (t *Best_Result) FromAlbum(v Album) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlbum performs a merge with any union data inside the Best_Result, using the provided Album
func (t *Best_Result) MergeAlbum(v Album) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaylist returns the union data inside the Best_Result as a Playlist
func (t Best_Result) AsPlaylist() (Playlist, error) {
	var body Playlist
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaylist overwrites any union data inside the Best_Result as the provided Playlist
func (t *Best_Result) FromPlaylist(v Playlist) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaylist performs a merge with any union data inside the Best_Result, using the provided Playlist
func (t *Best_Result) MergePlaylist(v Playlist) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideo returns the union data inside the Best_Result as a Video
func (t Best_Result) AsVideo() (Video, error) {
	var body Video
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideo overwrites any union data inside the Best_Result as the provided Video
func (t *Best_Result) FromVideo(v Video) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideo performs a merge with any union data inside the Best_Result, using the provided Video
func (t *Best_Result) MergeVideo(v Video) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Best_Result) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Best_Result) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
