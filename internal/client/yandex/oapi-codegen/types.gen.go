// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package client

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
)

const (
	OAuthScopes        = "oAuth.Scopes"
	OAuthProxiedScopes = "oAuthProxied.Scopes"
)

// Defines values for AlbumMetaType.
const (
	AlbumMetaTypeMusic   AlbumMetaType = "music"
	AlbumMetaTypePodcast AlbumMetaType = "podcast"
	AlbumMetaTypeSingle  AlbumMetaType = "single"
)

// Defines values for AlbumType.
const (
	AlbumTypePodcast AlbumType = "podcast"
	AlbumTypeSingle  AlbumType = "single"
)

// Defines values for CoverType.
const (
	Mosaic CoverType = "mosaic"
	Pic    CoverType = "pic"
)

// Defines values for PlaylistVisibility.
const (
	Private PlaylistVisibility = "private"
	Public  PlaylistVisibility = "public"
)

// Defines values for TrackDownloadInfoCodec.
const (
	Aac TrackDownloadInfoCodec = "aac"
	Mp3 TrackDownloadInfoCodec = "mp3"
)

// Album defines model for Album.
type Album struct {
	// Artists Артисты
	Artists []Artist `json:"artists"`

	// Available Доступен ли альбом
	Available bool `json:"available"`

	// AvailableForMobile Доступен ли альбом из приложения для телефона
	AvailableForMobile bool `json:"availableForMobile"`

	// AvailableForPremiumUsers Доступен ли альбом для пользователей с подпиской
	AvailableForPremiumUsers bool `json:"availableForPremiumUsers"`

	// AvailablePartially Доступен ли альбом частично для пользователей без подписки
	AvailablePartially bool `json:"availablePartially"`

	// Bests ID лучших треков альбома
	Bests []float32                `json:"bests"`
	Buy   []map[string]interface{} `json:"buy"`

	// CoverUri Ссылка на обложку
	CoverUri string `json:"coverUri"`

	// Error Ошибка получения альбома
	Error *string `json:"error"`

	// Genre Жанр музыки
	Genre string `json:"genre"`

	// Id Идентификатор альбома
	Id float32 `json:"id"`

	// Labels Лейблы
	Labels []AlbumLabels `json:"labels"`

	// MetaType Мета тип
	MetaType AlbumMetaType `json:"metaType"`

	// OgImage Ссылка на превью Open Graph
	OgImage string `json:"ogImage"`

	// Prerolls Прероллы
	Prerolls []map[string]interface{} `json:"prerolls"`

	// Recent Является ли альбом новым
	Recent bool `json:"recent"`

	// ReleaseDate Дата релиза в формате ISO 8601
	ReleaseDate string `json:"releaseDate"`

	// Title Название альбома
	Title string `json:"title"`

	// TrackCount Количество треков.
	TrackCount float32 `json:"trackCount"`

	// Type Тип альбома
	Type AlbumType `json:"type"`

	// VeryImportant Популярен ли альбом у слушателей
	VeryImportant bool `json:"veryImportant"`

	// Volumes Треки альбома, разделенные по дискам.
	Volumes *[][]Track `json:"volumes"`

	// Year Год релиза
	Year float32 `json:"year"`
}

// AlbumMetaType Мета тип
type AlbumMetaType string

// AlbumType Тип альбома
type AlbumType string

// AlbumLabels defines model for Album_labels.
type AlbumLabels struct {
	Id   *float32 `json:"id,omitempty"`
	Name *string  `json:"name,omitempty"`
}

// Artist defines model for Artist.
type Artist struct {
	Composer      bool                      `json:"composer"`
	Cover         *Cover                    `json:"cover,omitempty"`
	Decomposed    *[]map[string]interface{} `json:"decomposed"`
	Genres        []map[string]interface{}  `json:"genres"`
	Id            Artist_Id                 `json:"id"`
	Name          string                    `json:"name"`
	PopularTracks *[]Track                  `json:"popularTracks"`
	Regions       *[]string                 `json:"regions"`

	// TicketsAvailable Имеются ли в продаже билеты на концерт
	TicketsAvailable *bool `json:"ticketsAvailable"`
	Various          bool  `json:"various"`
}

// ArtistId0 defines model for .
type ArtistId0 = string

// ArtistId1 defines model for .
type ArtistId1 = float32

// Artist_Id defines model for Artist.Id.
type Artist_Id struct {
	union json.RawMessage
}

// Cover defines model for Cover.
type Cover struct {
	Custom bool `json:"custom"`

	// Dir Существует когда поле type = "pic"
	Dir *string `json:"dir,omitempty"`

	// Error If exists other properties is missing
	Error *string `json:"error,omitempty"`

	// ItemsUri Существует когда поле type = "mosaic"
	ItemsUri *[]string `json:"itemsUri,omitempty"`
	Type     CoverType `json:"type"`

	// Uri Существует когда поле type = "pic"
	Uri     *string `json:"uri,omitempty"`
	Version *string `json:"version,omitempty"`
}

// CoverType defines model for Cover.Type.
type CoverType string

// Genre defines model for Genre.
type Genre struct {
	// Color Цвет фона изображения
	Color       *string `json:"color,omitempty"`
	ComposerTop bool    `json:"composerTop"`

	// FullTitle Полный заголовок
	FullTitle *string `json:"fullTitle,omitempty"`

	// HideInRegions В каких регионах скрывать жанр
	HideInRegions *[]float32 `json:"hideInRegions,omitempty"`

	// Id Уникальный идентификатор жанра
	Id string `json:"id"`

	// Images Изображение жанра
	Images    map[string]string `json:"images"`
	RadioIcon *Icon             `json:"radioIcon,omitempty"`

	// ShowInMenu Показывать в меню
	ShowInMenu bool `json:"showInMenu"`

	// ShowInRegions Список регионов в которых отображается жанр в списках
	ShowInRegions *[]float32 `json:"showInRegions,omitempty"`
	SubGenres     *Genre     `json:"subGenres,omitempty"`

	// Title Заголовок жанра
	Title string `json:"title"`

	// Titles Словарь заголовков на разных языках, где ключ - язык
	Titles map[string]GenreTitles `json:"titles"`

	// UrlPart Часть ссылки на жанр для открытия в браузере
	UrlPart *string `json:"urlPart,omitempty"`

	// Weight Вес TODO (возможно, чем выше показатель, тем больше нравится пользователю)
	Weight float32 `json:"weight"`
}

// GenreTitles defines model for Genre_titles.
type GenreTitles struct {
	FullTitle string `json:"fullTitle"`
	Title     string `json:"title"`
}

// Icon defines model for Icon.
type Icon struct {
	BackgroundColor string `json:"backgroundColor"`
	ImageUrl        string `json:"imageUrl"`
}

// InvocationInfo defines model for InvocationInfo.
type InvocationInfo struct {
	AppName            *string `json:"app-name,omitempty"`
	ExecDurationMillis float32 `json:"exec-duration-millis"`
	Hostname           string  `json:"hostname"`
	ReqId              string  `json:"req-id"`
}

// Owner defines model for Owner.
type Owner struct {
	Login    string  `json:"login"`
	Name     string  `json:"name"`
	Sex      string  `json:"sex"`
	Uid      float32 `json:"uid"`
	Verified bool    `json:"verified"`
}

// Playlist play list data
type Playlist struct {
	Available            bool                      `json:"available"`
	BackgroundColor      string                    `json:"backgroundColor"`
	Collective           bool                      `json:"collective"`
	Cover                *Cover                    `json:"cover,omitempty"`
	Created              string                    `json:"created"`
	Description          string                    `json:"description"`
	DescriptionFormatted string                    `json:"descriptionFormatted"`
	DurationMs           float32                   `json:"durationMs"`
	IsBanner             bool                      `json:"isBanner"`
	IsPremiere           bool                      `json:"isPremiere"`
	Kind                 float32                   `json:"kind"`
	LikesCount           float32                   `json:"likesCount"`
	Modified             string                    `json:"modified"`
	OgImage              *string                   `json:"ogImage,omitempty"`
	Owner                Owner                     `json:"owner"`
	PlaylistUuid         string                    `json:"playlistUuid"`
	Prerolls             *[]map[string]interface{} `json:"prerolls,omitempty"`
	Revision             float32                   `json:"revision"`
	Snapshot             float32                   `json:"snapshot"`
	Tags                 []PlaylistTags            `json:"tags"`
	TextColor            string                    `json:"textColor"`
	Title                string                    `json:"title"`
	TrackCount           float32                   `json:"trackCount"`
	Tracks               []TrackItem               `json:"tracks"`
	Uid                  float32                   `json:"uid"`
	Visibility           PlaylistVisibility        `json:"visibility"`
}

// PlaylistVisibility defines model for Playlist.Visibility.
type PlaylistVisibility string

// PlaylistTags defines model for Playlist_tags.
type PlaylistTags struct {
	Id    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Track defines model for Track.
type Track struct {
	Albums                         []Album  `json:"albums"`
	Artists                        []Artist `json:"artists"`
	Available                      bool     `json:"available"`
	AvailableForPremiumUsers       bool     `json:"availableForPremiumUsers"`
	AvailableFullWithoutPermission bool     `json:"availableFullWithoutPermission"`

	// CoverUri Cover uri template
	CoverUri          string             `json:"coverUri"`
	DurationMs        float32            `json:"durationMs"`
	FileSize          float32            `json:"fileSize"`
	Id                string             `json:"id"`
	LyricsAvailable   bool               `json:"lyricsAvailable"`
	Major             TrackMajor         `json:"major"`
	Normalization     TrackNormalization `json:"normalization"`
	OgImage           string             `json:"ogImage"`
	PreviewDurationMs float32            `json:"previewDurationMs"`
	RealId            string             `json:"realId"`
	RememberPosition  bool               `json:"rememberPosition"`
	StorageDir        string             `json:"storageDir"`
	Title             string             `json:"title"`
	Type              string             `json:"type"`
}

// TrackDownloadInfo информация о вариантах загрузки трека
type TrackDownloadInfo struct {
	// BitrateInKbps Битрейт аудиофайла в кбит/с
	BitrateInKbps float32 `json:"bitrateInKbps"`

	// Codec Кодек аудиофайла
	Codec TrackDownloadInfoCodec `json:"codec"`

	// Direct Прямая ли ссылка
	Direct bool `json:"direct"`

	// DownloadInfoUrl Ссылка на XML документ содержащий данные для загрузки трека
	DownloadInfoUrl string `json:"downloadInfoUrl"`

	// Gain Усиление
	Gain bool `json:"gain"`

	// Preview Предварительный просмотр
	Preview string `json:"preview"`
}

// TrackDownloadInfoCodec Кодек аудиофайла
type TrackDownloadInfoCodec string

// TrackItem defines model for TrackItem.
type TrackItem struct {
	Id        float32 `json:"id"`
	PlayCount float32 `json:"playCount"`
	Recent    bool    `json:"recent"`
	Timestamp string  `json:"timestamp"`
	Track     *Track  `json:"track,omitempty"`
}

// TrackMajor defines model for Track_major.
type TrackMajor struct {
	Id   float32 `json:"id"`
	Name string  `json:"name"`
}

// TrackNormalization defines model for Track_normalization.
type TrackNormalization struct {
	Gain float32 `json:"gain"`
	Peak float32 `json:"peak"`
}

// InlineResponse20024 defines model for inline_response_200_24.
type InlineResponse20024 struct {
	InvocationInfo InvocationInfo `json:"invocationInfo"`

	// Result play list data
	Result Playlist `json:"result"`
}

// InlineResponse20030 defines model for inline_response_200_30.
type InlineResponse20030 struct {
	InvocationInfo InvocationInfo      `json:"invocationInfo"`
	Result         []TrackDownloadInfo `json:"result"`
}

// AsArtistId0 returns the union data inside the Artist_Id as a ArtistId0
func (t Artist_Id) AsArtistId0() (ArtistId0, error) {
	var body ArtistId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtistId0 overwrites any union data inside the Artist_Id as the provided ArtistId0
func (t *Artist_Id) FromArtistId0(v ArtistId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtistId0 performs a merge with any union data inside the Artist_Id, using the provided ArtistId0
func (t *Artist_Id) MergeArtistId0(v ArtistId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArtistId1 returns the union data inside the Artist_Id as a ArtistId1
func (t Artist_Id) AsArtistId1() (ArtistId1, error) {
	var body ArtistId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtistId1 overwrites any union data inside the Artist_Id as the provided ArtistId1
func (t *Artist_Id) FromArtistId1(v ArtistId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtistId1 performs a merge with any union data inside the Artist_Id, using the provided ArtistId1
func (t *Artist_Id) MergeArtistId1(v ArtistId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Artist_Id) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Artist_Id) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
